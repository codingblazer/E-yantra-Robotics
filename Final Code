/*
? * Team Id :eYRC-HD#3761
? * Team Leader:Sachin Aggarwal
? * Author List :Sachin Aggarwal,Hitesh Rishi,Sachin Gupta
? * Filename:final.c
? * Theme: Hazardous Waste Disposal 
? * Functions: buzzer_pin_config (void), servo1_pin_config (void), servo2_pin_config (void), servo3_pin_config (void), color_sensor_pin_config(void), 
left_encoder_pin_config (void), right_encoder_pin_config (void), lcd_port_config (void), adc_pin_config (void), motion_pin_config (void), port_init(),
left_position_encoder_interrupt_init (void), right_position_encoder_interrupt_init (void), timer5_init(),timer1_init(void), adc_init(),
char ADC_Conversion(unsigned char Ch), print_sensor(char row, char coloumn,unsigned char channel), int Sharp_GP2D12_estimation(unsigned char adc_reading), 
color_sensor_pin_interrupt_init(void), velocity (unsigned char left_motor, unsigned char right_motor), motion_set (unsigned char Direction), 
angle_rotate(unsigned int Degrees), left_degrees(unsigned int Degrees), right_degrees(unsigned int Degrees), soft_left_degrees(unsigned int Degrees), 
soft_right_degrees(unsigned int Degrees), soft_left_2_degrees(unsigned int Degrees), soft_right_2_degrees(unsigned int Degrees), forward (void), back (void),
 stop (void), left (void), right (void), soft_left (void), soft_right (void), soft_left_2 (void), soft_right_2 (void), init_devices, filter_red(void),
 filter_green(void), filter_blue(void), filter_clear(void), color_sensor_scaling(),red_read(void), green_read(void), blue_read(void), check_color(void),
 servo_1(unsigned char degrees), servo_2(unsigned char degrees), servo_3(unsigned char degrees), servo_1_free (void), servo_2_free (void), servo_3_free (void), 
blackline(),turn_left(),center_left(),turn_right(),center_right(),buzzer_on (void), buzzer_off(void), linear_distance_mm(unsigned int DistanceInMM), 
forward_mm(unsigned int DistanceInMM), back_mm(unsigned int DistanceInMM), rotation_using_blackline_right(void), rotation_using_blackline_left(void), 
sense_top2_HZ_waste_block_color(void), pick_the_top_HZ_waste(),drop_the_block(void), pick_top_weight_block(),pick_bottom_weight_block(),main(void)
? * Global Variables:ShaftCountLeft,ShaftCountRight,Degrees,flag1_color,flag2_color,flag3_color,
                    top_HZ_waste_block_color,middle_HZ_waste_color,bottom_HZ_waste_block_color,bottom_position
					pulse,red,green,blue,value.
? * 
? */	
	
	#define F_CPU 14745600
	#include <avr/io.h>
	#include <avr/interrupt.h>
	#include <util/delay.h>
	#include "lcd.h"

    volatile unsigned long int ShaftCountLeft = 0; //to keep track of left position encoder
	volatile unsigned long int ShaftCountRight = 0; //to keep track of right position encoder
	volatile unsigned int Degrees;
	//to accept angle in degrees for turning
	char flag1_color,flag2_color,flag3_color,top_HZ_waste_block_color,middle_HZ_waste_color,bottom_HZ_waste_block_color,bottom_position; // to store the colors of hazardous waste blocks and color of flags




	volatile unsigned long int pulse = 0; //to keep the track of the number of pulses generated by the color sensor
	volatile unsigned long int red;       // variable to store the pulse count when read_red function is called
	volatile unsigned long int blue;      // variable to store the pulse count when read_blue function is called
	volatile unsigned long int green;     // variable to store the pulse count when read_green function is called


void buzzer_pin_config (void)
	{
	 DDRC = DDRC | 0x08;    //Setting PORTC 3 as output
	 PORTC = PORTC & 0xF7;    //Setting PORTC 3 logic low to turnoff buzzer
	}

	//Configure PORTB 5 pin for servo motor 1 operation
	void servo1_pin_config (void)
	{
	 DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
	 PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
	}

	//Configure PORTB 6 pin for servo motor 2 operation
	void servo2_pin_config (void)
	{
	 DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
	 PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
	}

	//Configure PORTB 7 pin for servo motor 3 operation
	void servo3_pin_config (void)
	{
	 DDRB  = DDRB | 0x80;  //making PORTB 7 pin output
	 PORTB = PORTB | 0x80; //setting PORTB 7 pin to logic 1
	}
	void color_sensor_pin_config(void)
	{
	  DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
	  PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
	}


	void port_init();
	void timer5_init();
	void velocity(unsigned char, unsigned char);
	void motors_delay();

	unsigned char ADC_Conversion(unsigned char);
	unsigned char ADC_Value;
	unsigned char sharp, distance, adc_reading;
	unsigned int value;
	unsigned char flag = 0;
	unsigned char Left_white_line = 0;
	unsigned char Center_white_line = 0;
	unsigned char Right_white_line = 0;

	void left_encoder_pin_config (void)
	{
		DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
		PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
	}

	//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
	void right_encoder_pin_config (void)
	{
		DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
		PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
	}


	//Function to configure LCD port
	void lcd_port_config (void)
	{
	 DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
	 PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
	}

	//ADC pin configuration
	void adc_pin_config (void)
	{
	 DDRF = 0x00;
	 PORTF = 0x00;
	 DDRK = 0x00;
	 PORTK = 0x00;
	}

	//Function to configure ports to enable robot's motion
	void motion_pin_config (void)
	{
	 DDRA = DDRA | 0x0F;
	 PORTA = PORTA & 0xF0;
	 DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
	 PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
	}
	//ISR for color sensor
	ISR(INT0_vect)
	{
	  pulse++; //increment on receiving pulse from the color sensor
	}

	//Function to Initialize PORTS
	void port_init()
	{
		buzzer_pin_config();
		servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
	 	servo2_pin_config(); //Configure PORTB 6 pin for servo motor 2 operation
	 	servo3_pin_config(); //Configure PORTB 7 pin for servo motor 3 operation
		color_sensor_pin_config();  //color sensor pin configuration
	  	lcd_port_config();
		adc_pin_config();
		motion_pin_config();
		left_encoder_pin_config(); //left encoder pin config
		right_encoder_pin_config(); //right encoder pin config
	}
	void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
	{
		cli(); //Clears the global interrupt
		EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
		EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
		sei();   // Enables the global interrupt
	}

	void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
	{
		cli(); //Clears the global interrupt
		EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
		EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
		sei();   // Enables the global interrupt
	}
	ISR(INT5_vect)
	{
		ShaftCountRight++;  //increment right shaft position count
	}


	//ISR for left position encoder
	ISR(INT4_vect)
	{
		ShaftCountLeft++;  //increment left shaft position count
	}


	// Timer 5 initialized in PWM mode for velocity control
	// Pre-scale:256
	// PWM 8bit fast, TOP=0x00FF
	// Timer Frequency:225.000Hz
	void timer5_init()
	{
		TCCR5B = 0x00;	//Stop
		TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
		TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
		OCR5AH = 0x00;	//Output compare register high value for Left Motor
		OCR5AL = 0xFF;	//Output compare register low value for Left Motor
		OCR5BH = 0x00;	//Output compare register high value for Right Motor
		OCR5BL = 0xFF;	//Output compare register low value for Right Motor
		OCR5CH = 0x00;	//Output compare register high value for Motor C1
		OCR5CL = 0xFF;	//Output compare register low value for Motor C1
		TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
	 					  For Overriding normal port functionality to OCRnA outputs.
					  	  {WGM51=0, WGM80=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/

		TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
	}
	void timer1_init(void)
	{
	 TCCR1B = 0x00; //stop
	 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
	 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
	 OCR1AH = 0x03;	//Output compare Register high value for servo 1
	 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
	 OCR1BH = 0x03;	//Output compare Register high value for servo 2
	 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
	 OCR1CH = 0x03;	//Output compare Register high value for servo 3
	 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
	 ICR1H  = 0x03;
	 ICR1L  = 0xFF;
	 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
	 					For Overriding normal port functionality to OCRnA outputs.
					  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
	 TCCR1C = 0x00;
	 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
	}


	void adc_init()
	{
		ADCSRA = 0x00;
		ADCSRB = 0x00;		//MUX5 = 0
		ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
		ACSR = 0x80;
		ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
	}

	//Function For ADC Conversion
	unsigned char ADC_Conversion(unsigned char Ch)
	{
		unsigned char a;
		if(Ch>7)
		{
			ADCSRB = 0x08;
		}
		Ch = Ch & 0x07;
		ADMUX= 0x20| Ch;
		ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
		while((ADCSRA&0x10)==0);	//Wait for conversion to complete
		a=ADCH;
		ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
		ADCSRB = 0x00;
		return a;
	}

	//Function To Print Sensor Values At Desired Row And Column Location on LCD
	void print_sensor(char row, char coloumn,unsigned char channel)
	{

		ADC_Value = ADC_Conversion(channel);
		lcd_print(row, coloumn, ADC_Value, 3);
	}
	// This Function calculates the actual distance in millimeters(mm) from the input
	// analog value of Sharp Sensor.
	unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
	{
		float distance;
		unsigned int distanceInt;
		distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
		distanceInt = (int)distance;
		if(distanceInt>800)
		{
			distanceInt=800;
		}
		return distanceInt;
	}

	void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
	{
	  cli(); //Clears the global interrupt
	  EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
	  EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
	  sei(); // Enables the global interrupt
	}

	//Function for velocity control
	void velocity (unsigned char left_motor, unsigned char right_motor)
	{
		OCR5AL = (unsigned char)left_motor;
		OCR5BL = (unsigned char)right_motor;
	}

	//Function used for setting motor's direction
	void motion_set (unsigned char Direction)
	{
	 unsigned char PortARestore = 0;

	 Direction &= 0x0F; 		// removing upper nibbel for the protection
	 PortARestore = PORTA; 		// reading the PORTA original status
	 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
	 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
	 PORTA = PortARestore; 		// executing the command
	}
	void angle_rotate(unsigned int Degrees)
	{
		float ReqdShaftCount = 0;
		unsigned long int ReqdShaftCountInt = 0;

		ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
		ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
		ShaftCountRight = 0;
		ShaftCountLeft = 0;

		while (1)
		{
			if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
			break;
		}
		stop(); //Stop robot
	}
	void left_degrees(unsigned int Degrees)
	{
		// 88 pulses for 360 degrees rotation 4.090 degrees per count
		left(); //Turn left
		angle_rotate(Degrees);
	}



	void right_degrees(unsigned int Degrees)
	{
		// 88 pulses for 360 degrees rotation 4.090 degrees per count
		right(); //Turn right
		angle_rotate(Degrees);
	}


	void soft_left_degrees(unsigned int Degrees)
	{
		// 176 pulses for 360 degrees rotation 2.045 degrees per count
		soft_left(); //Turn soft left
		Degrees=Degrees*2;
		angle_rotate(Degrees);
	}

	void soft_right_degrees(unsigned int Degrees)
	{
		// 176 pulses for 360 degrees rotation 2.045 degrees per count
		soft_right();  //Turn soft right
		Degrees=Degrees*2;
		angle_rotate(Degrees);
	}

	void soft_left_2_degrees(unsigned int Degrees)
	{
		// 176 pulses for 360 degrees rotation 2.045 degrees per count
		soft_left_2(); //Turn reverse soft left
		Degrees=Degrees*2;
		angle_rotate(Degrees);
	}

	void soft_right_2_degrees(unsigned int Degrees)
	{
		// 176 pulses for 360 degrees rotation 2.045 degrees per count
		soft_right_2();  //Turn reverse soft right
		Degrees=Degrees*2;
		angle_rotate(Degrees);
	}


	void forward (void)
	{
	  motion_set (0x06);
	}

	void back (void) //both wheels backward
	{
	  motion_set(0x09);
	}

	void stop (void)
	{
	  motion_set (0x00);
	}

	void left (void) //Left wheel backward, Right wheel forward
	{
	  motion_set(0x05);
	}

	void right (void) //Left wheel forward, Right wheel backward
	{
	  motion_set(0x0A);
	}

	void soft_left (void) //Left wheel stationary, Right wheel forward
	{
	 motion_set(0x04);
	}

	void soft_right (void) //Left wheel forward, Right wheel is stationary
	{
	 motion_set(0x02);
	}

	void soft_left_2 (void) //Left wheel backward, right wheel stationary
	{
	 motion_set(0x01);
	}

	void soft_right_2 (void) //Left wheel stationary, Right wheel backward
	{
	 motion_set(0x08);
	}

	void init_devices (void)
	{
	 	cli(); //Clears the global interrupts
		port_init();
		adc_init();
		timer5_init();
		left_position_encoder_interrupt_init();
		right_position_encoder_interrupt_init();
		color_sensor_pin_interrupt_init();
		timer1_init();
		sei();   //Enables the global interrupts
	}


	//Filter Selection
	void filter_red(void)    //Used to select red filter
	{
	  //Filter Select - red filter
	  PORTD = PORTD & 0xBF; //set S2 low
	  PORTD = PORTD & 0x7F; //set S3 low
	}

	void filter_green(void) //Used to select green filter
	{
	  //Filter Select - green filter
	  PORTD = PORTD | 0x40; //set S2 High
	  PORTD = PORTD | 0x80; //set S3 High
	}

	void filter_blue(void)  //Used to select blue filter
	{
	  //Filter Select - blue filter
	  PORTD = PORTD & 0xBF; //set S2 low
	  PORTD = PORTD | 0x80; //set S3 High
	}

	void filter_clear(void) //select no filter
	{
	  //Filter Select - no filter
	  PORTD = PORTD | 0x40; //set S2 High
	  PORTD = PORTD & 0x7F; //set S3 Low
	}

	//Color Sensing Scaling

	/*
	 * Function Name: color_sensor_scaling
	 * Logic: This function is used to select the scaled down version of the original frequency of the output generated by the color sensor.
	 * Example Call: color_sensor_scaling();
	 */

	void color_sensor_scaling()
	{
	  //Output Scaling 20% from datasheet though it can be changed by refering to datasheet
	  //PORTD = PORTD & 0xEF;
	  PORTD = PORTD | 0x10; //set S0 high
	  //PORTD = PORTD & 0xDF; //set S1 low
	  PORTD = PORTD | 0x20; //set S1 high
	}


	/*
	 * Function Name: red_read
	 * Input: capture the pulses for 100 ms or 0.1 second, store the count in variable called red.
	 * Output: None
	 * Logic: function to select red filter and display the count generated by the sensor on LCD.
	          The count will be more if the color is red. The count will be very less if its blue or green or any other color.
	 * Example Call: red_read();
	 *
	 */

	void red_read(void)
	{
	  //Red
	  filter_red(); //select red filter
	  pulse=0; //reset the count to 0
	  _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	  red = pulse;  //store the count in variable called red
	  }


	/*
	 * Function Name: green_read
	 * Input: capture the pulses for 100 ms or 0.1 second, store the count in variable called green.
	 * Output: None
	 * Logic: function to select green filter and display the count generated by the sensor on LCD.
	          The count will be more if the color is green. The count will be very less if its blue or red.
	 * Example Call: green_read();
	 *
	 */
	void green_read(void)
	{
	  //Green
	  filter_green(); //select green filter
	  pulse=0; //reset the count to 0
	  _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	  green = pulse;  //store the count in variable called green
	   //Clear the LCD
	}


	/*
	 * Function Name: green_read
	 * Input: capture the pulses for 100 ms or 0.1 second, store the count in variable called green.
	 * Output: None
	 * Logic: function to select blue filter and display the count generated by the sensor on LCD.
	          The count will be more if the color is blue. The count will be very less if its red or green.
	 * Example Call: blue_read();
	 *
	 */

	void blue_read(void)
	{
	  //Blue
	  filter_blue(); //select blue filter
	  pulse=0; //reset the count to 0
	  _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	  blue = pulse;  //store the count in variable called blue
	  //Clear the LCD
	}

	/*
	 * Function Name: check_color
	 * Input: None
	 * Output: Characters 'R','B','G' on the basis of defined conditions in logic.
	 * Logic: Three different conditions for checking the colors.
	          eg: if red color pulse is maximum(compared from green and blue pulses) then it detects a red color and returns 'r'
	          similarly for other 2 colors.
	 * Example Call: check_color();
	 */
	char check_color(void)
	{

         red_read();
		_delay_ms(1000);   //display the pulse count when red filter is selected
	    green_read(); //display the pulse count when green filter is selected
		_delay_ms(1000);
	    blue_read();  //display the pulse count when blue filter is selected
	 _delay_ms(1000);
	     if((red>green) && (red>blue))
	     {
	        return 'R'; //red color  
	     }
	     if((blue>green) && (blue>red))
	     {
	        return 'B'; //blue color
	     }
	     if((green>red) && (green>blue))
	     {
	        return 'G'; //green color

	     }
	    
	}


	void servo_1(unsigned char degrees)
	{
	 float PositionPanServo = 0;
	  PositionPanServo = ((float)degrees / 1.86) + 35.0;
	 OCR1AH = 0x00;
	 OCR1AL = (unsigned char) PositionPanServo;
	}


	//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
	void servo_2(unsigned char degrees)
	{
	 float PositionTiltServo = 0;
	 PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	 OCR1BH = 0x00;
	 OCR1BL = (unsigned char) PositionTiltServo;
	}

	//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
	void servo_3(unsigned char degrees)
	{
	 float PositionServo = 0;
	 PositionServo = ((float)degrees / 1.86) + 35.0;
	 OCR1CH = 0x00;
	 OCR1CL = (unsigned char) PositionServo;
	}

	void servo_1_free (void) //makes servo 1 free rotating
	{
	 OCR1AH = 0x03;
	 OCR1AL = 0xFF; //Servo 1 off
	}

	void servo_2_free (void) //makes servo 2 free rotating
	{
	 OCR1BH = 0x03;
	 OCR1BL = 0xFF; //Servo 2 off
	}

	void servo_3_free (void) //makes servo 3 free rotating
	{
	 OCR1CH = 0x03;
	 OCR1CL = 0xFF; //Servo 3 off
	}


	/*
	 * Function Name: blackline
	 * Variables: None
	 * Input: Left_white_line, Center_white_line, Right_white_line variable values, which are actually the three white line sensor values
	 	respectively.
	 * Output: Corresponding motion according to the combination defined in logic.
	 * Logic: Sensors can have seven different conditions inside on basis of 7 different combinations of sensor values.
	 	The combination is commented just above each condition as 010, 101, 111, 000 etc.
	 	0 corresponds for a white region and 1 corresponds for a black region.
	 	eg: 010 represents: Left_white_line sensor color : white
	 						Center_white_line sensor color : black
	 						Right_white_line sensor color : white
		A node is defined when all three white line sensors detect black color. 
		0x0c is the threshold sensor value upto which the sensor reads a white color.
	 * Example Call: backline();
	 
	 
	 */
	int blackline()
	{
		while(1){
			Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
			Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
			Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

			if(Center_white_line>0x20 && Left_white_line<0x20 && Right_white_line<0x20) // Center on black line-010
			{	forward();
				velocity(130,122); //velocity value calibrated as per requirement

			}

			else if((Left_white_line>0x20 && Center_white_line<0x20) ) //left sensor on black line, take left turn to get back on blackline
			{
				forward();
				velocity(40,120); //velocity of left and right motors calibrated as per requirement
				_delay_ms(15);
			}

			else if((Right_white_line>0x20 && Center_white_line<0x20)) //right sensor on black line, take right turn to get back on blackline
			{	forward();
				velocity(120,40);
				_delay_ms(15);
			}
			else if(Center_white_line>0x20 && Left_white_line>0x20 && Right_white_line<0x20){//110
				stop();
				return;
			}
			else if(Center_white_line<0x20 && Left_white_line>0x20 && Right_white_line>0x20){//101
				stop();
				return;
			}
			else if(Center_white_line>0x20 && Left_white_line>0x20 && Right_white_line>0x20){//111
				stop();
				return;
			}
			else if(Center_white_line>0x20 && Left_white_line<0x20 && Right_white_line>0x20){//011
				stop();
				return;
			}

		}

	}

	/*
	 * Function Name: turn_left
	 * Input: Left_white_line,  which is actually the value of leftmost white line sensor.
	 * Output: Helps in taking a restricted left turn on the basis of certain condition that is defined in logic.
	 * Logic: Takes a left until its left sensor gets a black value.
	 	0x0c is the threshold sensor value upto which the sensor reads a white color.
	 * Example Call: turn_left();
	
	 */

	void turn_left()
	{
		left();
		while(1)
		{

			Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
			Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
			Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

			flag=0;

			print_sensor(1,1,3);	//Prints value of White Line Sensor1
			print_sensor(1,5,2);	//Prints Value of White Line Sensor2
			print_sensor(1,9,1);	//Prints Value of White Line Sensor3

			velocity(140,140);
			_delay_ms(6);
			if(Left_white_line>=0x40)
			{	stop();
				velocity(0,0);
				return;
			}

		}
	}

	/*
	 * Function Name: center_left
	 * Input: Center_white_line,  which is actually the value of center white line sensor.
	 * Output: Rotates the robot to take a restricted right turn.
	 * Logic: Takes a right until its center sensor gets a black value.
	 	0x0c is the threshold sensor value upto which the sensor reads a white color.
	 * Example Call: center_left();

	 */

	void center_left()
	{
		soft_right_2();
		while(1)
		{

			Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
			Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
			Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

			flag=0;

			print_sensor(1,1,3);	//Prints value of White Line Sensor1
			print_sensor(1,5,2);	//Prints Value of White Line Sensor2
			print_sensor(1,9,1);	//Prints Value of White Line Sensor3

			velocity(0,130);
			_delay_ms(6);
			if(Center_white_line>=0x0b)
			{
				velocity(0,0);

				return;
			}

		}
	}


	/*
	 * Function Name: turn_right
	 * Input: Right_white_line,  which is actually the value of rightmost white line sensor.
	 * Output: Helps in taking a restricted right turn on the basis of certain condition that is defined in logic.
	 * Logic: Takes a right until its right sensor gets a black value.
	 	0x0c is the threshold sensor value upto which the sensor reads a white color.
	 * Example Call: turn_right();
	
	 */

	void turn_right()
	{
		right();
		while(1)
		{

			Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
			Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
			Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

			flag=0;

			print_sensor(1,1,3);	//Prints value of White Line Sensor1
			print_sensor(1,5,2);	//Prints Value of White Line Sensor2
			print_sensor(1,9,1);	//Prints Value of White Line Sensor3

			velocity(140,140);
			_delay_ms(6);
			if(Right_white_line>=0x40)
			{
				velocity(0,0);

				return;
			}


		}
	}


	/*
	 * Function Name: center_right
	 * Input: Center_white_line,  which is actually the value of center white line sensor.
	 * Output: Rotates the robot to take a restricted left turn.
	 * Logic: Takes a left until its center sensor gets a black value.
	 	0x0c is the threshold sensor value upto which the sensor reads a white color.
	 * Example Call: center_right();
	 
	 */
	void center_right()
	{
		soft_left_2();
		while(1)
		{

			Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
			Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
			Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

			flag=0;

			print_sensor(1,1,3);	//Prints value of White Line Sensor1
			print_sensor(1,5,2);	//Prints Value of White Line Sensor2
			print_sensor(1,9,1);	//Prints Value of White Line Sensor3

			velocity(130,0);
			_delay_ms(6);
			if(Center_white_line>=0x0b)
			{
				velocity(0,0);

				return;
			}

		}
	}

	

	
	
	void buzzer_on (void)
	{
	 unsigned char port_restore = 0;
	 port_restore = PINC;
	 port_restore = port_restore | 0x08;
	 PORTC = port_restore;
	}

	void buzzer_off (void)
	{
	 unsigned char port_restore = 0;
	 port_restore = PINC;
	 port_restore = port_restore & 0xF7;
	 PORTC = port_restore;
	}
	
	
	//Function used for moving robot forward by specified distance

	void linear_distance_mm(unsigned int DistanceInMM)
	{
		float ReqdShaftCount = 0;
		unsigned long int ReqdShaftCountInt = 0;

		ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
		ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;

		ShaftCountRight = 0;
		while(1)
		{
			if(ShaftCountRight > ReqdShaftCountInt)
			{
				break;
			}
		}
		stop(); //Stop robot
	}

	void forward_mm(unsigned int DistanceInMM)
	{
		forward();
		linear_distance_mm(DistanceInMM);
	}

	void back_mm(unsigned int DistanceInMM)
	{
		back();
		linear_distance_mm(DistanceInMM);
	}
	
	/*
	? * Function Name:rotation_using_blackline_right
	? * Logic: This function is used to rotate robot right until it finds a blakline.It is used only when robot is at a node.
	          Since robot will be at node it must be moved from it or otherwise turn_right function will keep robot at same position.
			  Thus robot is forwarded and then turn_right function is called. 
	? * Example Call:rotation_using_blackline_right
	? */
	void rotation_using_blackline_right(void)
	{
	forward_mm(89); //robot is forwarded by fixed distance using encoder
	stop();
	_delay_ms(500);
	turn_right();  //robot will rotate right until it gets blackline
	velocity(150,150);
	_delay_ms(50);
	stop();

	}
	/*
	? * Function Name:rotation_using_blackline_left
	? * Logic: This function is used to rotate robot left until it finds a blakline.It is used only when robot is at a node.
	          Since robot will be at node it must be moved from it or otherwise turn_left function will keep robot at same position.
			  Thus robot is forwarded and then turn_left function is called. 
	? * Example Call: rotation_using_blackline_left();
	? */
	void rotation_using_blackline_left(void)
	{
		forward_mm(89); //robot is forwarded by fixed distance using encoder
		stop();
		_delay_ms(500);
		turn_left();     //robot will rotate right until it gets blackline
		velocity(150,150);
		_delay_ms(50);
		stop();

	}
	/*
	? * Function Name: sense_top2_HZ_waste_block_color
	? * Logic:This function will be used to sense the color of top 2 High CCL hazardous waste blocks.
	Color sensor is mounted on the gripper and thus gripper as closed and arm is moved to bring.
	Once color of top 2 blocks are known remaining color out of R,G,B will be color of bottommost Low CCL block 
	the color sensor in front of blocks and sense the color of top 2 blocks one by one.
	? * Example Call: sense_top2_HZ_waste_block_color();
	? */
	
	void sense_top2_HZ_waste_block_color(void)
	{
		_delay_ms(500);
		velocity(130,135);
		back_mm(30);   //robot must move some back distance before closing the gripper otherwise gripper will hit the blocks.
		velocity(115,110);
	servo_1(0);         
		_delay_ms(1000);
		servo_3(140);        //gripper closes
		_delay_ms(1000);
		servo_2(135);          //gripper i.e. color sensor brought in front of middle block
		_delay_ms(1000);
		for(int i=0;i<=40;i+=10)  //to bring gripper exactly in front of  gripper
		{
			servo_1(i);
			_delay_ms(1000);


		}
		

middle_HZ_waste_color=check_color();  //color of middle block is stored in middle_HZ_waste_color
_delay_ms(1000);
servo_1(26);                          //bring the gripper i.e. color sensor in front of top HZ block 
_delay_ms(1000);
top_HZ_waste_block_color=check_color();                    //color of top block is stored in top_HZ_waste_block
_delay_ms(5000);
		// color sensing done 
		if(top_HZ_waste_block_color!='R' && middle_HZ_waste_color!='R')
		bottom_HZ_waste_block_color='R';
		else if(top_HZ_waste_block_color!='G' && middle_HZ_waste_color!='G')
		bottom_HZ_waste_block_color='G';
		else if(top_HZ_waste_block_color!='B' && middle_HZ_waste_color!='B')
		bottom_HZ_waste_block_color='B';
		
	}
	/*
	? * Function Name:  pick_the_top_HZ_waste
	? * Logic: This function is used to pick the topmost HZ waste using robotic arm.
	This function is used just after sense_top2_HZ_waste_block_color function. 
	? * Example Call: pick_the_top_HZ_waste();
	? */
	void pick_the_top_HZ_waste()
	{

		servo_3(0); //open the gripper
		forward_mm(24); //robot moved forward to be able to contain the block
		velocity(160,120);
		_delay_ms(1000);
		stop();
		
		for(int i=0;i<=25;i+=5)   //bring the arm to contain the block
		{
			servo_1(i);
			_delay_ms(1000);
			
			
		}
		servo_3(114);  //close the gripper
		_delay_ms(2000);
		servo_1(0);   //lift the HZ block
	}
	
	/*
	? * Function Name: drop_the_block
	? * Logic:This function is used to drop the weight block into the container or colored hazardous block at deposition zones using robotic arm
	? * Example Call: drop_the_block
	? */
	
	void drop_the_block(void)
	{
		servo_1(0);
		_delay_ms(1000);    
		servo_2(85);      //bring arm near container
		_delay_ms(1000);
		servo_3(0);  //open the gripper
		_delay_ms(1000);
	}
	/*
	? * Function Name: pick_top_weight_block
	? * Logic:This function is used to pick the top weight block from stack of two weight blocks
	Arm is brought at the height of top weight block and gripper is then brought to contain the weight block. 
	? * Example Call: pick_top_weight_block();
	? */

void pick_top_weight_block() 
{
	
	servo_3(0); //open the gripper
	_delay_ms(500);
	servo_2(155);  //set angle for gripper so that gripper can contain weight block properly
	_delay_ms(1000);
	for(int i=0;i<=55;i+=5)  //bring arm down to top weight block
	{
		servo_1(i);
		_delay_ms(200);
	}
	servo_3(131);  // gripper closes
	_delay_ms(2000);
	
	servo_1(0); //left the weight block
}

/*
	? * Function Name: pick_bottom_weight_block
	? * Logic:This function is used to pick the bottom weight block.
	This function will be used only when top weight block has been already picked
	? * Example Call:pick_bottom_weight_block();
	? */
void pick_bottom_weight_block()
{
	servo_3(0); //open the gripper
	_delay_ms(2000);
	 servo_2(165); //set the gripper position so that it can contain the weight block
	_delay_ms(1000);
	for(int i=0;i<=80;i+=5)  //loop is used so that arm move smoothly as otherwise weight block might get mispositioned when arm come near to it. 
	{
		servo_1(i);              
		_delay_ms(200);
	}
	servo_3(135); //close the gripper
	_delay_ms(2000);
	
	servo_1(0);  //lift the weight block
	_delay_ms(1000);

}

/*
? * Function Name: main(void)
? * Input :None
? * Output:None
? * Logic: This function is responsible for complete algorithm implementation.Robot will traverse and complete the theme tasks according to 
    commands of this function.
	Algorithm Logic-
	1.Sharp Distance sensor will read the orientation of bridge.
    2.Now we have 2 possibilities- Bridge is tilted towards City Area initially which is "IN FAVOUR" case for us AND
	other possibility is that bridge is "NOT IN FAVOUR" for us.
	3.Now,if bridge is in favour -we will sense the color of waste blocks and cross the bridge easily and will reach node corresponding to flag 2
	where we will again use color sensor to determine the color of all the three flags(but HOW??--"its coded below").
	However,if bridge is not in favour,then we will first put one weight block from W1 and then follow the same procedure as in above case.Thus,here 
	also we would be knowing the color of all 3 flags and all 3 hazardous waste blocks.
	4.Now at this point we know the color of all 3 flags and all 3 hazardous waste blocks.Now with this information, we can know that 
	what is the location (out of flag A/B/C) of the bottommost Low CCL waste block.Thus,there arises three possible cases-Low CCL block matches i.e.
	is to be placed at location A,location B,or location C.
	5.We have used above logic because-We observed that W3 weight blocks are most near to the container while other weight blocks are very far.
	We made all possible combinations and found that if we can somehow ensure that W3 weight blocks are always used,that will result in most optimum 
	solution in every possible case.It is obvious that we will be needing weight blocks only when top and middle waste block are placed at their 
	location.Thus,we can distribute our problem to 3 cases according to bottommost block correct location.
	6.Thus we have picked all these cases and in every case we have finded the most optimum approach which will result in most optimum approach 
	for our whole solution 
? * Example Call:main();
? */
	

unsigned int value;
///////////////////////////////////////////////THE MAIN FUNCTION STARTS////////////////////////////////////////////////////
	int main(void)
{
	//initializing the required functions or ports etc //
        color_sensor_scaling();
		init_devices();
		lcd_set_4bit();
		lcd_init();

		servo_1(0); //main arm brought vertically upward at 90 degrees
		_delay_ms(1000);
		servo_3(0); //servo3 i.e. gripper opens
		_delay_ms(1000);
		servo_2(135); ///servo 2 vertically upward
		_delay_ms(1000);
	//////////////////////////////////////////////
	
	
	//DISTANCE SENSOR WILL READ THE ORIENTATION OF BRIDGE
	sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
	value = Sharp_GP2D12_estimation(sharp);		    //Stores Distance calCulated in a variable "value".
	lcd_print(2,14,value,3);  
/*//////////////////////////////////*/

//In FAVOUR STARTS In FAVOUR STARTS In FAVOUR STARTS In FAVOUR STARTS In FAVOUR STARTS In FAVOUR STARTSIn FAVOUR STARTS In FAVOUR STARTS
if(value<500)
{
	forward_mm(37);//35
	velocity(144,135);
	stop();
	_delay_ms(1000);

	turn_right();
	velocity(150,150);
	_delay_ms(50);
	stop();
	turn_right();
	velocity(150,150);
	_delay_ms(50);
	stop();
	//now facing towards the hazardous blocks

	sense_top2_HZ_waste_block_color();
	
	turn_right();
	velocity(150,150);
	_delay_ms(50);
	stop();
	turn_right();
	velocity(150,150);
	_delay_ms(50);
	stop();
	blackline();
	_delay_ms(1000);
	
	//bridge crossed successfully
	
	forward_mm(21);
	stop();
	_delay_ms(500);
	blackline();
	_delay_ms(1000);

	//now it will sense the color of flag 2
	servo_1(0);
	servo_2(135);
	servo_3(112);
	//initial positions of servos adjusted as it will hit flag if it is done later
	
	blackline();
	forward_mm(60);
	stop();
	_delay_ms(1000);
	blackline();
	forward_mm(185);
	stop();
	_delay_ms(1000);
	velocity(150,150);
	soft_right_2_degrees(92);
	velocity(190,180);
	stop();
	_delay_ms(500);
	velocity(182,180);
	back_mm(60);
	servo_1(0);
	servo_2(43);
	_delay_ms(1000);
	//now color sensor can read color easily
	flag2_color=check_color();
	//color of flag 2 read successfully and now we will turn robot towards flag 3
	forward_mm(70);
	_delay_ms(5000);
	right_degrees(178);
	velocity(180,180);
	stop();
	back_mm(110);
	//we will adjust arm so that color sensor faces flag 3
	for (int i=135;i>=45;i-=5)
	{
		servo_2(i);
		_delay_ms(500);
	}
	flag3_color=check_color();
	//flag3_color color is successfully read
	
	///TO FIND THE COLOR OF flag1_color
	//Since we are given that there are 3 colors-Red,Green and Blue of flag and since we now know the color of two of them,remaining color will be
	//color of flag 1
	if(flag3_color!='R' && flag2_color!='R')
	{
		flag1_color='R';
	}
	else if(flag3_color!='G' && flag2_color!='G')
	{
		flag1_color='G';
	}
	else if(flag3_color!='B' && flag2_color!='B')
	{
		flag1_color='B';
	}
	//color of flag 1 known successfully

	//now we will below determine the correct location of bottommost Low CCL block out of A/B/C
	/////////////////////////////TO DETERMINE BOTTOM BLOCK"S POSITION OUT OF A/B/C
	
	if(flag1_color==bottom_HZ_waste_block_color && flag2_color!=bottom_HZ_waste_block_color && flag3_color!=bottom_HZ_waste_block_color)
	bottom_position='A';
	if(flag2_color==bottom_HZ_waste_block_color && flag1_color!=bottom_HZ_waste_block_color && flag3_color!=bottom_HZ_waste_block_color)
	bottom_position='B';
	if(flag3_color==bottom_HZ_waste_block_color && flag2_color!=bottom_HZ_waste_block_color && flag1_color!=bottom_HZ_waste_block_color)
	bottom_position='C';


	/////////////////////////////////starting  coding for all 3 cases here/////////////////////////////////////////////////////////////////////////////////////////
	///CASE 1-Bottommost block to be placed at Location A
	if(bottom_position=='A')
	{
		
		if(top_HZ_waste_block_color==flag3_color)//IT MEANS THAT MID WASTE BLOCK IS AT FLAG 2,BOTTOM AT flag1_color,TOP AT flag3_color
		{
			
			rotation_using_blackline_left();
			
			blackline();
			_delay_ms(1000);
			
			rotation_using_blackline_right();
			
			blackline();
			
			forward_mm(22);
			turn_right();
			velocity(190,180);
			stop();
			_delay_ms(1000);
			
			blackline();
			//////now drop the color box at C
			drop_the_block();
			rotation_using_blackline_left();
			_delay_ms(1000);
			blackline();
			/// pick the weight from W4
			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{
				servo_1(i);
				_delay_ms(200);
			}
			
			servo_3(131);
			_delay_ms(2000);
			rotation_using_blackline_left();
			blackline();
			forward_mm(23);//
			velocity(190,180);
			stop();
			blackline();
			rotation_using_blackline_right();
			/// drop the weight box in container
			drop_the_block();
			forward_mm(24);//
			rotation_using_blackline_right();
			blackline();
			forward_mm(23);
			turn_left();
			velocity(190,180);
			stop();
			_delay_ms(1000);
			blackline();
			// CROSSING THE BRIDGE
			// NOW WE ArE IN CITY 1
			turn_left();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			velocity(190,180);
			forward_mm(113);
			stop();
			_delay_ms(1000);
			velocity(190,180);
			left_degrees(88);
			velocity(190,180);
			stop();
			_delay_ms(500);
			velocity(182,180);
			back_mm(83);
			stop();
			_delay_ms(500);
			// PICK THE WEIGTH BOX FROM W3
			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{


				servo_1(i);
				_delay_ms(200);
			}
			
			servo_3(131);
			_delay_ms(2000);
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			stop();
			_delay_ms(500);
			velocity(150,150);
			forward_mm(39);
			blackline();
			forward_mm(3);
			rotation_using_blackline_right();
			// DROP THE BOX IN CONTAINER OF CITY 1
			drop_the_block();
			forward_mm(24);//
			rotation_using_blackline_left();
			blackline();
			// pick the weight box from weight W5
			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{


				servo_1(i);
				_delay_ms(200);
			}
			
			servo_3(131);
			_delay_ms(2000);
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			stop();
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			//.. drop the weight box in container
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			forward_mm(8);
			rotation_using_blackline_right();
			// pick the middle box
			servo_2(135);
			_delay_ms(1000);
			servo_3(0);
			_delay_ms(1000);
			for(int i=0;i<=40;i+=5)
			{
				servo_1(i);
				_delay_ms(1000);


			}
			_delay_ms(1000);
			servo_3(114);
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			// now crossing the bridge second time
			forward_mm(21);
			stop();
			_delay_ms(500);
			blackline();
			_delay_ms(1000);
			// drop the color box at b
			drop_the_block();
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			// pick the weight box from weight b

			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{


				servo_1(i);
				_delay_ms(200);
			}
			
			servo_3(131);
			_delay_ms(2000);
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			forward_mm(23);
			velocity(190,180);
			stop();
			blackline();
			rotation_using_blackline_right();
			/// drop the weight box in container
			drop_the_block();
			forward_mm(24);
			rotation_using_blackline_right();
			_delay_ms(1000);
			blackline();
			// pick the weight box from weight W3
			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{


				servo_1(i);
				_delay_ms(200);
			}
			servo_3(131);
			_delay_ms(2000);
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			forward_mm(24);
			rotation_using_blackline_left();
			// drop the weight box in container
			drop_the_block();
			forward_mm(24);
			rotation_using_blackline_right();
			blackline();
			forward_mm(23);
			turn_left();
			velocity(190,180);
			stop();
			_delay_ms(1000);
			blackline();
			// CROSSING THE BRIDGE
			// NOW WE ARE IN CITY 1
			turn_left();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			velocity(190,180);
			forward_mm(113);
			stop();
			_delay_ms(1000);
			velocity(190,180);
			left_degrees(88);
			velocity(190,180);
			stop();
			_delay_ms(500);
			velocity(182,180);
			back_mm(83);
			stop();
			_delay_ms(500);
			// PICK THE WEIGTH BOX FROM W3
			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{


				servo_1(i);
				_delay_ms(200);
			}
			
			servo_3(131);
			_delay_ms(2000);
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			stop();
			_delay_ms(500);
			velocity(150,150);
			forward_mm(39);
			blackline();
			forward_mm(3);
			rotation_using_blackline_right();
			// DROP THE BOX IN CONTAINER
			drop_the_block();
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			// pick the weight box from weight b
			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{


				servo_1(i);
				_delay_ms(200);
			}
			
			servo_3(131);
			_delay_ms(2000);
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			stop();
			forward_mm(24);
			
			rotation_using_blackline_left();
			blackline();
			//.. drop the weight box in container
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			forward_mm(8);
			rotation_using_blackline_right();
			// pick the bottom box
			servo_2(135);
			_delay_ms(1000);
			servo_3(0);
			_delay_ms(1000);
			for(int i=0;i<=40;i+=5)
			{
				servo_1(i);
				_delay_ms(1000);


			}
			_delay_ms(1000);
			servo_3(114);
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			// now crossing the bridge last time
			// we are in city 2
			forward_mm(24);
			rotation_using_blackline_right();
			blackline();
			forward();
			velocity(190,180);
			blackline();

			velocity(190,180);
			forward_mm(113);
			stop();
			_delay_ms(1000);
			velocity(190,180);
			left_degrees(88);
			velocity(190,180);
			stop();
			_delay_ms(500);
			blackline();
			// drop the color box at A
			drop_the_block();
		}

		//////////////////////////////////////////////////////////////////////////////



		else if(flag2_color==top_HZ_waste_block_color)  //IT MEANS BOTTOM AT flag1_color OR A,TOP AT FLAG 2,WHICH MEANS MID AT flag3_color
		{
			rotation_using_blackline_right();
			//DROP THE BOX AT B
			forward_mm(35);
			rotation_using_blackline_right();
			blackline();
			forward_mm(22);
			turn_right();
			velocity(190,180);
			stop();
			_delay_ms(1000);
			blackline();
			/// pick the weight from W5
			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{
				servo_1(i);
				_delay_ms(200);
			}
			
			servo_3(131);
			_delay_ms(2000);
			rotation_using_blackline_left();
			blackline();
			forward_mm(23);
			velocity(190,180);
			stop();
			blackline();
			rotation_using_blackline_right();
			/// drop the weight box in container
			drop_the_block();
			forward_mm(24);//
			rotation_using_blackline_right();
			blackline();
			forward_mm(23);///
			turn_left();
			velocity(190,180);
			stop();
			_delay_ms(1000);
			blackline();
			// CROSSING THE BRIDGE
			// NOW we are IN CITY 1
			turn_left();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			velocity(190,180);
			forward_mm(113);
			stop();
			_delay_ms(1000);
			velocity(190,180);
			left_degrees(88);
			velocity(190,180);
			stop();
			_delay_ms(500);
			velocity(182,180);
			back_mm(83);
			stop();
			_delay_ms(500);
			// PICK THE WEIGTH BOX FROM W3
			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{


				servo_1(i);
				_delay_ms(200);
			}
			servo_3(131);
			_delay_ms(2000);
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			stop();
			_delay_ms(500);
			velocity(150,150);
			forward_mm(39);
			blackline();
			forward_mm(3);
			rotation_using_blackline_right();
			// DROP THE bOX IN CONTAINER OF CITY 1
			drop_the_block();
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			// pick the weight box from W5
			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{


				servo_1(i);
				_delay_ms(200);
			}
			servo_3(131);
			_delay_ms(2000);
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			stop();
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			//.. drop the weight box in container
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			forward_mm(8);
			rotation_using_blackline_right();
			// pick the middle box
			servo_2(135);
			_delay_ms(1000);
			servo_3(0);
			_delay_ms(1000);
			for(int i=0;i<=40;i+=5)
			{
				servo_1(i);
				_delay_ms(1000);


			}
			_delay_ms(1000);
			servo_3(114);
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			// now crossing the bridge second time
			forward_mm(40);
			_delay_ms(1000);
			rotation_using_blackline_left();
			blackline();
			forward_mm(112);
			_delay_ms(1000);
			rotation_using_blackline_right();
			blackline();
			// drop the color box at C
			drop_the_block();
			forward_mm(50);
			rotation_using_blackline_right();
			blackline();
			
			// pick the weight box from W4

			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{


				servo_1(i);
				_delay_ms(200);
			}
			
			servo_3(131);
			_delay_ms(2000);
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			forward_mm(23);
			velocity(190,180);
			stop();
			blackline();
			rotation_using_blackline_right();
			/// drop the weight box in container
			drop_the_block();
			forward_mm(24);//
			rotation_using_blackline_right();
			_delay_ms(1000);
			blackline();
			// pick the weight box from weight W3
			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{


				servo_1(i);
				_delay_ms(200);
			}
			
			servo_3(131);
			_delay_ms(2000);
			forward_mm(24);//
			rotation_using_blackline_left();
			blackline();
			forward_mm(24);
			rotation_using_blackline_left();
			// drop the weight box in container
			drop_the_block();
			forward_mm(24);//
			rotation_using_blackline_right();
			blackline();
			forward_mm(23);///
			turn_left();
			velocity(190,180);
			stop();
			_delay_ms(1000);
			blackline();
			// CROSSING THE BRIDGE
			// NOW WE ARE IN CITY 1
			turn_left();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			velocity(190,180);
			forward_mm(113);
			stop();
			_delay_ms(1000);
			velocity(190,180);
			left_degrees(88);
			velocity(190,180);
			stop();
			_delay_ms(500);
			velocity(182,180);
			back_mm(83);
			stop();
			_delay_ms(500);
			// PICK THE WEIGTH BOX FROM W3
			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{


				servo_1(i);
				_delay_ms(200);
			}
			
			servo_3(131);
			_delay_ms(2000);
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			stop();
			_delay_ms(500);
			velocity(150,150);
			forward_mm(39);
			blackline();
			forward_mm(3);
			rotation_using_blackline_right();
			// DROP THE BOX IN CONTAINER
			drop_the_block();
			forward_mm(24);//
			rotation_using_blackline_left();
			blackline();
			// pick the weight box from W5
			servo_2(155);
			_delay_ms(1000);
			for(int i=0;i<=54;i+=2)
			{


				servo_1(i);
				_delay_ms(200);
			}
			
			servo_3(131);
			_delay_ms(2000);
			forward_mm(24);
			rotation_using_blackline_left();
			blackline();
			stop();
			forward_mm(24);//
			rotation_using_blackline_left();
			blackline();
			//.. drop the weight box in container
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			forward_mm(8);
			rotation_using_blackline_right();
			// pick the bottom box
			servo_2(135);
			_delay_ms(1000);
			servo_3(0);
			_delay_ms(1000);
			for(int i=0;i<=40;i+=5)
			{
				servo_1(i);
				_delay_ms(1000);


			}
			_delay_ms(1000);
			servo_3(114);
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			turn_right();
			velocity(150,150);
			_delay_ms(50);
			stop();
			blackline();
			// now crossing the bridge last time
			// we are in city 2
			forward_mm(24);//
			rotation_using_blackline_right();
			blackline();
			forward();
			velocity(190,180);
			blackline();

			velocity(190,180);
			forward_mm(113);
			stop();
			_delay_ms(1000);
			velocity(190,180);
			left_degrees(88);
			velocity(190,180);
			stop();
			_delay_ms(500);
			blackline();
			// drop the color box at A
			drop_the_block();
			
		}}
		//////////////////////////////////////////CASE 2--BOTTOMMOST BLOCK AT LOCATION B//////////////////////////////////////////////////
		if(bottom_position=='B')
		{
			if(flag3_color==top_HZ_waste_block_color) //THUS BOTTOM AT B,TOP AT C WHICH MEANS MID AT A
			{
				rotation_using_blackline_left();
				blackline();
				_delay_ms(1000);
				rotation_using_blackline_right();
				blackline();
				forward_mm(22);
				turn_right();
				velocity(190,180);
				stop();
				_delay_ms(1000);
				blackline();
				//////now drop the color box at C
				drop_the_block();
				rotation_using_blackline_left();
				_delay_ms(1000);
				blackline();
				/// pick the weight from W4
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{
					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				rotation_using_blackline_left();
				blackline();
				forward_mm(23);//
				velocity(190,180);
				stop();
				blackline();
				rotation_using_blackline_right();
				/// drop the weight box in container
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_right();
				blackline();
				forward_mm(23);
				turn_left();
				velocity(190,180);
				stop();
				_delay_ms(1000);
				blackline();
				// CROSSING THE BRIDGE
				// Now we are in CITY 1
				turn_left();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				velocity(190,180);
				forward_mm(113);
				stop();
				_delay_ms(1000);
				velocity(190,180);
				left_degrees(88);
				velocity(190,180);
				stop();
				_delay_ms(500);
				velocity(182,180);
				back_mm(83);
				stop();
				_delay_ms(500);
				// PICK THE WEIGTH BOX FROM W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				_delay_ms(500);
				velocity(150,150);
				forward_mm(39);
				blackline();
				forward_mm(3);
				rotation_using_blackline_right();
				// DROP THE BOX IN CONTAINER OF CITY 1
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				// pick the weight box from W5
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				//.. drop the weight box in container
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				forward_mm(8);
				rotation_using_blackline_right();
				// pick the middle box
				servo_2(135);
				_delay_ms(1000);
				servo_3(0);
				_delay_ms(1000);
				for(int i=0;i<=40;i+=5)
				{
					servo_1(i);
					_delay_ms(1000);


				}
				_delay_ms(1000);
				servo_3(114);
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				// now crossing the bridge second time
				forward_mm(24);//
				rotation_using_blackline_right();
				blackline();
				forward();
				velocity(190,180);
				blackline();

				velocity(190,180);
				forward_mm(113);
				stop();
				_delay_ms(1000);
				velocity(190,180);
				left_degrees(88);
				velocity(190,180);
				stop();
				_delay_ms(500);
				blackline();
				//DROP THE COLOR BOX AT A
				drop_the_block();
				
				forward_mm(40);
				rotation_using_blackline_right();
				blackline();
				forward_mm(100);
				turn_left(88);
				// pick the weight box from W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				forward_mm(24);
				rotation_using_blackline_left();
				// drop the weight box in container
				drop_the_block();
				rotation_using_blackline_left();
				blackline();
				// PICK THE WEIGHT BOX FROM WEIGTH W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				forward_mm(24);
				rotation_using_blackline_left();
				// drop the weight box in container
				drop_the_block();

				forward_mm(24);//
				rotation_using_blackline_right();
				blackline();
				forward_mm(23);///
				turn_left();
				velocity(190,180);
				stop();
				_delay_ms(1000);
				blackline();
				// CROSSING THE BRIDGE
				// NOW WE ARE IN CITY 1
				turn_left();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				velocity(190,180);
				forward_mm(113);
				stop();
				_delay_ms(1000);
				velocity(190,180);
				left_degrees(88);
				velocity(190,180);
				stop();
				_delay_ms(500);
				velocity(182,180);
				back_mm(83);
				stop();
				_delay_ms(500);
				// PICK THE WEIGTH BOX FROM W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				_delay_ms(500);
				velocity(150,150);
				forward_mm(39);
				blackline();
				forward_mm(3);
				rotation_using_blackline_right();
				// DROP THE BOX IN CONTAINER
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				// pick the weight box from W5
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				//.. drop the weight box in container
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				forward_mm(8);
				rotation_using_blackline_right();
				// pick the bottom box
				servo_2(135);
				_delay_ms(1000);
				servo_3(0);
				_delay_ms(1000);
				for(int i=0;i<=40;i+=5)
				{
					servo_1(i);
					_delay_ms(1000);


				}
				_delay_ms(1000);
				servo_3(114);
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				// now crossing the bridge last time
				// we are in city 2
				forward_mm(24);
				velocity(140,140);
				blackline();
				// drop the color box at B
				drop_the_block();
				
			}
			
			////////////////////////////////////////////////////////////////////////////////////////////////
			
			else if(flag1_color==top_HZ_waste_block_color) //THUS BOTTOM AT B,TOP AT A WHICH MEANS MID AT C
			{
				rotation_using_blackline_left();
				blackline();
				_delay_ms(1000);
				rotation_using_blackline_left();
				blackline();
				forward_mm(22);
				velocity(140,140);
				blackline();
				turn_left();
				velocity(190,180);
				stop();
				_delay_ms(1000);
				blackline();
				//////now drop the color box at A
				drop_the_block();
				/////////////////////////////////////
				forward_mm(40);
				rotation_using_blackline_right();
				blackline();
				forward_mm(100);
				turn_left(88);
				// pick the weight box from W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				forward_mm(24);
				rotation_using_blackline_left();
				// drop the weight box in container
				drop_the_block();
				rotation_using_blackline_right();
				blackline();
				forward();
				blackline();
				/////PICK THE WEIGHT BOX FROM W5
				servo_2(135);
				_delay_ms(1000);
				servo_3(0);
				_delay_ms(1000);
				for(int i=0;i<=40;i+=5)
				{
					servo_1(i);
					_delay_ms(1000);


				}
				_delay_ms(1000);
				servo_3(114);
				rotation_using_blackline_left();
				blackline();
				forward();
				blackline();
				rotation_using_blackline_right();
				//// drop the weight box in container
				drop_the_block();
				rotation_using_blackline_right();
				blackline();
				rotation_using_blackline_left();
				blackline();
				// CROSSING THE BRIDGE
				// Now we are in CITY 1
				turn_left();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				velocity(190,180);
				forward_mm(113);
				stop();
				_delay_ms(1000);
				velocity(190,180);
				left_degrees(88);
				velocity(190,180);
				stop();
				_delay_ms(500);
				velocity(182,180);
				back_mm(83);
				stop();
				_delay_ms(500);
				// PICK THE WEIGTH BOX FROM W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				_delay_ms(500);
				velocity(150,150);
				forward_mm(39);
				blackline();
				forward_mm(3);
				rotation_using_blackline_right();
				// DROP THE BOX IN CONTAINER OF CITY 1
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				// pick the weight box from W5
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				//.. drop the weight box in container
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				forward_mm(8);
				rotation_using_blackline_right();
				// pick the middle box
				servo_2(135);
				_delay_ms(1000);
				servo_3(0);
				_delay_ms(1000);
				for(int i=0;i<=40;i+=5)
				{
					servo_1(i);
					_delay_ms(1000);


				}
				_delay_ms(1000);
				servo_3(114);
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				// now crossing the bridge second time
				rotation_using_blackline_left();
				blackline();
				rotation_using_blackline_right();
				blackline();
				//DROP THE COLOR BOX AT C
				drop_the_block();
				rotation_using_blackline_right();
				blackline();
				// pick the weight box from W4
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				rotation_using_blackline_left();
				blackline();
				forward_mm(24);
				blackline();
				rotation_using_blackline_right();
				// drop the box in container
				drop_the_block();
				rotation_using_blackline_left();
				blackline();
				// PICK THE WEIGHT BOX FROM W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				forward_mm(24);
				rotation_using_blackline_left();
				// drop the weight box in container
				drop_the_block();

				forward_mm(24);//
				rotation_using_blackline_right();
				blackline();
				forward_mm(23);///
				turn_left();
				velocity(190,180);
				stop();
				_delay_ms(1000);
				blackline();
				// CROSSING THE BRIDGE
				// NOW WE ARE IN CITY 1
				turn_left();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				velocity(190,180);
				forward_mm(113);
				stop();
				_delay_ms(1000);
				velocity(190,180);
				left_degrees(88);
				velocity(190,180);
				stop();
				_delay_ms(500);
				velocity(182,180);
				back_mm(83);
				stop();
				_delay_ms(500);
				// PICK THE WEIGTH BOX FROM W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				_delay_ms(500);
				velocity(150,150);
				forward_mm(39);
				blackline();
				forward_mm(3);
				rotation_using_blackline_right();
				// DROP THE BOX IN CONTAINER
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				// pick the weight box from W5
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				//.. drop the weight box in container
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				forward_mm(8);
				rotation_using_blackline_right();
				// pick the bottom box
				servo_2(135);
				_delay_ms(1000);
				servo_3(0);
				_delay_ms(1000);
				for(int i=0;i<=40;i+=5)
				{
					servo_1(i);
					_delay_ms(1000);


				}
				_delay_ms(1000);
				servo_3(114);
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				// now crossing the bridge last time
				// we are in city 2
				forward_mm(24);
				velocity(140,140);
				blackline();
				// drop the color box at B
				drop_the_block();
				
			}
		}
		////////////////////////////////////////////////CASE 3-IN FAVOUR-BOTTOMMOST BLOCK AT LOCATION C//////////////////////////////////////
		if(bottom_position)
		{
			if(top_HZ_waste_block_color==flag1_color)///THUS BOTTOM AT C ,TOP AT A,WHICH MEANS MID AT B
			{
				rotation_using_blackline_left();
				blackline();
				_delay_ms(1000);
				rotation_using_blackline_left();
				blackline();
				forward_mm(22);
				velocity(140,140);
				blackline();
				turn_left();
				velocity(190,180);
				stop();
				_delay_ms(1000);
				blackline();
				//////now drop the color box at A
				drop_the_block();
				/////////////////////////////////////
				forward_mm(40);
				rotation_using_blackline_right();
				blackline();
				forward_mm(100);
				turn_left(88);
				// pick the weight box from W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				forward_mm(24);
				rotation_using_blackline_left();
				// drop the weight box in container
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_right();
				blackline();
				forward_mm(23);///
				turn_left();
				velocity(190,180);
				stop();
				_delay_ms(1000);
				blackline();
				// CROSSING THE BRIDGE
				// Now we are in CITY 1
				turn_left();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				velocity(190,180);
				forward_mm(113);
				stop();
				_delay_ms(1000);
				velocity(190,180);
				left_degrees(88);
				velocity(190,180);
				stop();
				_delay_ms(500);
				velocity(182,180);
				back_mm(83);
				stop();
				_delay_ms(500);
				// PICK THE WEIGTH BOX FROM W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				_delay_ms(500);
				velocity(150,150);
				forward_mm(39);
				blackline();
				forward_mm(3);
				rotation_using_blackline_right();
				// DROP THE BOX IN CONTAINER OF CITY 1
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				// pick the weight box from W5
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				//.. drop the weight box in container
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				forward_mm(8);
				rotation_using_blackline_right();
				// pick the middle box
				servo_2(135);
				_delay_ms(1000);
				servo_3(0);
				_delay_ms(1000);
				for(int i=0;i<=40;i+=5)
				{
					servo_1(i);
					_delay_ms(1000);


				}
				_delay_ms(1000);
				servo_3(114);
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				// now crossing the bridge second time
				forward_mm(24);
				blackline();
				//DROP THE COLOR BOX AT B
				drop_the_block();
				rotation_using_blackline_right();
				blackline();
				rotation_using_blackline_right();
				blackline();
				// pick the weight box from B
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				rotation_using_blackline_left();
				blackline();
				forward_mm(24);
				blackline();
				rotation_using_blackline_right();
				// drop the box in container
				drop_the_block();
				rotation_using_blackline_left();
				blackline();
				// PICK THE WEIGHT BOX FROM W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				forward_mm(24);
				rotation_using_blackline_left();
				// drop the weight box in container
				drop_the_block();

				forward_mm(24);//
				rotation_using_blackline_right();
				blackline();
				forward_mm(23);///
				turn_left();
				velocity(190,180);
				stop();
				_delay_ms(1000);
				blackline();
				// CROSSING THE BRIDGE
				// NOW WE ARE IN CITY 1
				turn_left();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				velocity(190,180);
				forward_mm(113);
				stop();
				_delay_ms(1000);
				velocity(190,180);
				left_degrees(88);
				velocity(190,180);
				stop();
				_delay_ms(500);
				velocity(182,180);
				back_mm(83);
				stop();
				_delay_ms(500);
				// PICK THE WEIGTH BOX FROM W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				_delay_ms(500);
				velocity(150,150);
				forward_mm(39);
				blackline();
				forward_mm(3);
				rotation_using_blackline_right();
				// DROP THE BOX IN CONTAINER
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				// pick the weight box from W5
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				//.. drop the weight box in container
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				forward_mm(8);
				rotation_using_blackline_right();
				// pick the bottom box
				servo_2(135);
				_delay_ms(1000);
				servo_3(0);
				_delay_ms(1000);
				for(int i=0;i<=40;i+=5)
				{
					servo_1(i);
					_delay_ms(1000);


				}
				_delay_ms(1000);
				servo_3(114);
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				// now crossing the bridge last time
				// we are in city 2
				rotation_using_blackline_left();
				blackline();
				forward_mm(100);
				rotation_using_blackline_right();
				blackline();
				// drop the color box at C
				drop_the_block();
				
			}
			////////////////////////////////////////////////////////////////////////////////////////
			if(top_HZ_waste_block_color==flag2_color)//WHICH MEANS TOP AT B ,BOTTOM AT C WHICH MEANS MID AT FLAG A
			{
				
				rotation_using_blackline_right();
				//DROP THE BOX AT B
				forward_mm(35);//
				rotation_using_blackline_right();
				blackline();
				forward_mm(22);
				turn_right();
				velocity(190,180);
				stop();
				_delay_ms(1000);
				blackline();
				/// pick the weight from W5
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{
					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				rotation_using_blackline_left();
				blackline();
				forward_mm(23);//
				velocity(190,180);
				stop();
				blackline();
				rotation_using_blackline_right();
				/// drop the weight box in container
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_right();
				blackline();
				forward_mm(23);///
				turn_left();
				velocity(190,180);
				stop();
				_delay_ms(1000);
				blackline();
				// CROSSING THE BRIDGE
				// Now we are in CITY 1
				turn_left();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				velocity(190,180);
				forward_mm(113);
				stop();
				_delay_ms(1000);
				velocity(190,180);
				left_degrees(88);
				velocity(190,180);
				stop();
				_delay_ms(500);
				velocity(182,180);
				back_mm(83);
				stop();
				_delay_ms(500);
				// PICK THE WEIGTH BOX FROM W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				_delay_ms(500);
				velocity(150,150);
				forward_mm(39);
				blackline();
				forward_mm(3);
				rotation_using_blackline_right();
				// DROP THE bOX IN CONTAINER OF CITY 1
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				// pick the weight box from W5
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				//.. drop the weight box in container
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				forward_mm(8);
				rotation_using_blackline_right();
				// pick the middle box
				servo_2(135);
				_delay_ms(1000);
				servo_3(0);
				_delay_ms(1000);
				for(int i=0;i<=40;i+=5)
				{
					servo_1(i);
					_delay_ms(1000);


				}
				_delay_ms(1000);
				servo_3(114);
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				// now crossing the bridge second time
				forward_mm(40);
				_delay_ms(1000);
				rotation_using_blackline_right();
				blackline();
				forward_mm(112);
				_delay_ms(1000);
				blackline();
				rotation_using_blackline_left();
				blackline();
				// drop the color box at A
				drop_the_block();
				rotation_using_blackline_right();
				blackline();
				forward_mm(113);
				turn_left(88);
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				rotation_using_blackline_right();
				blackline();
				rotation_using_blackline_left();
				/// drop the weight box in container
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_right();
				_delay_ms(1000);
				blackline();
				// pick the weight box from weight W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				forward_mm(24);
				rotation_using_blackline_left();
				// drop the weight box in container
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_right();
				blackline();
				forward_mm(23);///
				turn_left();
				velocity(190,180);
				stop();
				_delay_ms(1000);
				blackline();
				// CROSSING THE BRIDGE
				// NOW WE ARE IN CITY 1
				turn_left();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				velocity(190,180);
				forward_mm(113);
				stop();
				_delay_ms(1000);
				velocity(190,180);
				left_degrees(88);
				velocity(190,180);
				stop();
				_delay_ms(500);
				velocity(182,180);
				back_mm(83);
				stop();
				_delay_ms(500);
				// PICK THE WEIGTH BOX FROM W3
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				_delay_ms(500);
				velocity(150,150);
				forward_mm(39);
				blackline();
				forward_mm(3);
				rotation_using_blackline_right();
				// DROP THE BOX IN CONTAINER
				drop_the_block();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				// pick the weight box from W5
				servo_2(155);
				_delay_ms(1000);
				for(int i=0;i<=54;i+=2)
				{


					servo_1(i);
					_delay_ms(200);
				}
				
				servo_3(131);
				_delay_ms(2000);
				forward_mm(24);
				rotation_using_blackline_left();
				blackline();
				stop();
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				//.. drop the weight box in container
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				forward_mm(8);
				rotation_using_blackline_right();
				// pick the bottom box
				servo_2(135);
				_delay_ms(1000);
				servo_3(0);
				_delay_ms(1000);
				for(int i=0;i<=40;i+=5)
				{
					servo_1(i);
					_delay_ms(1000);


				}
				_delay_ms(1000);
				servo_3(114);
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				turn_right();
				velocity(150,150);
				_delay_ms(50);
				stop();
				blackline();
				// now crossing the bridge last time
				// we are in city 2
				forward_mm(24);//
				rotation_using_blackline_left();
				blackline();
				rotation_using_blackline_right();
				blackline();
				// drop the color box at C
				drop_the_block();
				
			}
			

	



	////////////////////////////BRIDGE IS "NOT IN FAVOUR"/////////////////////////////////////////////////////////////////////////
	else //which means bridge is not in favour
	{
		
		forward_mm(37);
		velocity(144,135);
		stop();

		_delay_ms(1000);

		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		
		blackline();
		
		//now we need to pick top weight W1

		forward_mm(113);
		stop();
		_delay_ms(1000);
		velocity(190,180);
		left_degrees(88);
		velocity(190,180);
		stop();
		_delay_ms(500);
		velocity(182,180);
		back_mm(83);
		stop();
		_delay_ms(500);

		pick_top_weight_block(); //will pick the weight block
		
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		_delay_ms(500);
		
		forward_mm(39);
		blackline();
		forward_mm(3);
		rotation_using_blackline_right();
		
		drop_the_block(); //will drop the weight block into the container

		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		forward_mm(8);
		rotation_using_blackline_right();
		//now facing towards hazardous wastes
		sense_top2_HZ_waste_block_color();
		//// sensed the color of top 2 blocks successfully

		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		_delay_ms(1000);
		
		//bridge crossed successfully
		
		forward_mm(21);
		stop();
		_delay_ms(500);
		blackline();
		_delay_ms(1000);

		//now it will sense the color of flag 2
		servo_1(0);
		servo_2(135);
		servo_3(112);
		//initial positions of servos adjusted as it will hit flag if it is done later
		
		blackline();
		forward_mm(60);
		stop();
		_delay_ms(1000);
		blackline();
		forward_mm(185);
		stop();
		_delay_ms(1000);
		velocity(150,150);
		soft_right_2_degrees(92);
		velocity(190,180);
		stop();
		_delay_ms(500);
		velocity(182,180);
		back_mm(60);
		servo_1(0);
		servo_2(43);
		_delay_ms(1000);
		//now color sensor can read color easily
		flag2_color=check_color();
		//color of flag 2 read successfully and now we will turn robot towards flag 3
		forward_mm(70);
		_delay_ms(5000);
		right_degrees(178);
		velocity(180,180);
		stop();
		back_mm(110);
		//we will adjust arm so that color sensor faces flag 3
		for (int i=135;i>=45;i-=5)
		{
			servo_2(i);
			_delay_ms(500);
		}
		flag3_color=check_color();
		//flag3_color color is successfully read
		
		///TO FIND THE COLOR OF flag1_color
		//Since we are given that there are 3 colors-Red,Green and Blue of flag and since we now know the color of two of them,remaining color will be
		//color of flag 1
		if(flag3_color!='R' && flag2_color!='R')
		{
			flag1_color='R';
		}
		else if(flag3_color!='G' && flag2_color!='G')
		{
			flag1_color='G';
		}
		else if(flag3_color!='B' && flag2_color!='B')
		{
			flag1_color='B';
		}
		//color of flag 1 known successfully

		//now we will below determine the correct location of bottommost Low CCL block out of A/B/C
		/////////////////////////////TO DETERMINE BOTTOM BLOCK"S POSITION OUT OF A/B/C
		
		if(flag1_color==bottom_HZ_waste_block_color && flag2_color!=bottom_HZ_waste_block_color && flag3_color!=bottom_HZ_waste_block_color)
		bottom_position='A';
		if(flag2_color==bottom_HZ_waste_block_color && flag1_color!=bottom_HZ_waste_block_color && flag3_color!=bottom_HZ_waste_block_color)
		bottom_position='B';
		if(flag3_color==bottom_HZ_waste_block_color && flag2_color!=bottom_HZ_waste_block_color && flag1_color!=bottom_HZ_waste_block_color)
		bottom_position='C';


		/////////////////////////////////starting  coding for all 3 cases here/////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////CASE 1 BOTTOM BLOCK AT FLAG A///////////////////////////////////////////
if(bottom_HZ_waste_block_color==flag1_color)
{
	if(flag2_color==top_HZ_waste_block_color)// TOP AT B,Bottom at A which means that mid block at C
	{
		
		rotation_using_blackline_right();
		//DROP THE BOX AT B
		drop_the_block();
		forward_mm(35);
		rotation_using_blackline_right();
		blackline();
		forward_mm(22);
		turn_right();
		velocity(190,180);
		stop();
		_delay_ms(1000);
		blackline();
		/// pick the weight from weight B
		pick_top_weight_block();
		rotation_using_blackline_left();
		blackline();
		forward_mm(23);
		velocity(190,180);
		stop();
		blackline();
		rotation_using_blackline_right();
		/// drop the weight box in conatiner
		drop_the_block();
		rotation_using_blackline_left();
		blackline();
		pick_top_weight_block();
		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_right();
		/// drop the weight box in conatiner
		drop_the_block();
		forward_mm(24);
		rotation_using_blackline_right();
		blackline();
		forward_mm(23);
		turn_left();
		velocity(190,180);
		stop();
		_delay_ms(1000);
		blackline();
		//BRIDGE CROSSED AND @ND RUN ON CITY AREA SIDE....AT NODE 'A' AND FACING TOWARDS HAZARDOUS WASTES
		// CROSSING THE BRIDGE
		// NOW WE AE IN CITY 1
		turn_left();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		velocity(190,180);
		forward_mm(113);
		stop();
		_delay_ms(1000);
		velocity(190,180);
		left_degrees(88);
		velocity(190,180);
		stop();
		_delay_ms(500);
		velocity(182,180);//187
		back_mm(83);//76
		stop();
		_delay_ms(500);
		// PICK THE WEIGHT BOX FROM WEIGHT A
		pick_top_weight_block();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		_delay_ms(500);
		velocity(150,150);
		forward_mm(39);
		blackline();
		forward_mm(3);
		rotation_using_blackline_right();
		// DROP THE bOX IN CONTAINER OF CITY 1
		drop_the_block();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		// pick the weight box from weight b
		pick_top_weight_block();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		//.. drop the wweight box in conntainer
		drop_the_block();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		forward_mm(8);
		rotation_using_blackline_right();
		// pick the middle box
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		//bring the arm in front of mid block
		//pick the mid block
		rotation_using_blackline_right();
		blackline();
		forward();
		velocity(95,90);
		stop();
		blackline();
		//bridge crossed succesfully
		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_right();
		blackline();
		//drop the color box
		drop_the_block();
		rotation_using_blackline_left();
		blackline();
		//pick wt block from weight C
		pick_top_weight_block();
		rotation_using_blackline_left();
		blackline();
		forward();
		blackline();
		rotation_using_blackline_right();
		//DROP THE WEIGHT BOX IN CONTAINER
		drop_the_block();
		rotation_using_blackline_left();
		blackline();
		/// pick the weight box from weight A
		pick_bottom_weight_block();
		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_right();
		/// drop the weight box in container
		drop_the_block();
		rotation_using_blackline_right();
		blackline();
		forward();
		blackline();
		//PICK THE WEIGHT BOX
		pick_bottom_weight_block();
		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_right();
		blackline();
		///3rd run for city area
		// CROSSING THE BRIDGE
		// NOW E AE IN CITY 1
		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_right();
		// DROP THE bOX IN CONTAINER OF CITY 1
		drop_the_block();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		// pick the weight box from weight b
		pick_bottom_weight_block();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		//.. drop the weight box in conntainer
		drop_the_block();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		forward_mm(8);
		rotation_using_blackline_right();
		// pick the bottom box
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		///// CROSS THE BRIDGE AGAIN
		rotation_using_blackline_right();
		blackline();
		forward();
		blackline();
		rotation_using_blackline_left();
		blackline();
		/// drop the bottom block
		drop_the_block();
	}
	else if(flag3_color==top_HZ_waste_block_color) //top at C,Bottom at A which means mid block to be placed at B
	{
		
		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_right();
		blackline();
		//DROP THE BOX AT C
		drop_the_block();
		rotation_using_blackline_right();
		blackline();
		/// pick the weight from weight C
		pick_top_weight_block();
		rotation_using_blackline_left();
		blackline();
		forward_mm(23);
		velocity(190,180);
		stop();
		blackline();
		rotation_using_blackline_right();
		/// drop the weight box in conatiner
		drop_the_block();
		rotation_using_blackline_left();
		blackline();
		pick_top_weight_block();
		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_right();
		/// drop the weight box in conatiner
		drop_the_block();
		forward_mm(24);
		rotation_using_blackline_right();
		blackline();
		forward_mm(23);
		turn_left();
		velocity(190,180);
		stop();
		_delay_ms(1000);
		blackline();
		//BRIDGE CROSSED AND @ND RUN ON CITY AREA SIDE....AT NODE 'A' AND FACING TOWARDS HAZARDOUS WASTES
		// CROSSING THE BRIDGE
		// NOW WE AE IN CITY 1
		turn_left();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		velocity(190,180);
		forward_mm(113);
		stop();
		_delay_ms(1000);
		velocity(190,180);
		left_degrees(88);
		velocity(190,180);
		stop();
		_delay_ms(500);
		velocity(182,180);//187
		back_mm(83);//76
		stop();
		_delay_ms(500);
		// PICK THE WEIGHT BOX FROM WEIGHT A
		pick_bottom_weight_block();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		_delay_ms(500);
		velocity(150,150);
		forward_mm(39);
		blackline();
		forward_mm(3);
		rotation_using_blackline_right();
		// DROP THE bOX IN CONTAINER OF CITY 1
		drop_the_block();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		// pick the weight box from weight b
		pick_top_weight_block();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		//.. drop the wweight box in conntainer
		drop_the_block();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		forward_mm(8);
		rotation_using_blackline_right();
		// pick the middle box
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		//bring the arm in front of mid block
		//pick the mid block
		pick_top_weight_block();
		rotation_using_blackline_right();
		blackline();
		forward();
		velocity(95,90);
		stop();
		blackline();
		//bridge crossed succesfully
		forward();
		blackline();
		//drop the color box
		drop_the_block();
		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_right();
		blackline();
		//pick wt block from weight B
		pick_top_weight_block();
		rotation_using_blackline_left();
		blackline();
		forward();
		blackline();
		rotation_using_blackline_right();
		//DROP THE WEIGHT BOX IN CONTAINER
		drop_the_block();
		rotation_using_blackline_left();
		blackline();
		/// pick the weight box from weight A
		pick_bottom_weight_block();
		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_right();
		/// drop the weight box in container
		drop_the_block();
		rotation_using_blackline_right();
		blackline();
		forward();
		blackline();
		//PICK THE WEIGHT BOX
		pick_bottom_weight_block();
		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_right();
		blackline();
		///3rd run for city area
		// CROSSING THE BRIDGE
		// NOW E AE IN CITY 1
		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_right();
		// DROP THE bOX IN CONTAINER OF CITY 1
		drop_the_block();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		// pick the weight box from weight b
		pick_bottom_weight_block();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		//.. drop the weight box in conntainer
		drop_the_block();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		forward_mm(8);
		rotation_using_blackline_right();
		// pick the bottom box
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		///// CROSS THE BRIDGE AGAIN
		rotation_using_blackline_right();
		blackline();
		forward();
		blackline();
		rotation_using_blackline_left();
		blackline();
		/// drop the bottom block
		drop_the_block();
	}
}
//////////////////////////////////////////////CASE 2 BOTTOM AT B///////////////////////////////////////////////////////
if(bottom_HZ_waste_block_color==flag2_color)
{
	
	if(flag1_color==top_HZ_waste_block_color)
	{
		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_left();
		blackline();
		forward_mm(24);
		blackline();
		rotation_using_blackline_left();
		blackline();
		//DROP THE BOX AT A
		rotation_using_blackline_right();
		blackline();
		left_degrees(88);
		stop();
		// pick the weight box from weight a
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{
			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_left();
		drop_the_block();
		rotation_using_blackline_right();
		blackline();
		forward_mm(24);
		blackline();
		/// pick the weight from weight B
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{
			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		rotation_using_blackline_left();
		blackline();
		forward_mm(23);// to be caliberated
		velocity(190,180);
		stop();
		blackline();
		rotation_using_blackline_right();
		/// drop the weight box in conatiner
		drop_the_block();////////////////////////////////
		
		rotation_using_blackline_right();
		blackline();
		forward();
		rotation_using_blackline_left();
		blackline();
		//BRIDGE CROSSED AND @ND RUN ON CITY AREA SIDE....AT NODE 'A' AND FACING TOWARDS HAZARDOUS WASTES
		// CROSSING THE BRIDGE
		// NOW E AE IN CITY 1
		turn_left();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		velocity(190,180);
		forward_mm(113);
		stop();
		_delay_ms(1000);
		velocity(190,180);
		left_degrees(88);
		velocity(190,180);
		stop();
		_delay_ms(500);
		velocity(182,180);//187
		back_mm(83);//76
		stop();
		_delay_ms(500);
		// PICK THE WEIGTH BOX FROM WEIGHT A
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{


			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		_delay_ms(500);
		velocity(150,150);
		forward_mm(39);
		blackline();
		forward_mm(3);
		rotation_using_blackline_right();
		// DROP THE bOX IN CONTAINER OF CITY 1
		drop_the_block();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_left();
		blackline();
		// pick the weight box from weight b
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{


			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_left();
		blackline();
		//.. drop the wweight box in conntainer
		drop_the_block();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		forward_mm(8);
		rotation_using_blackline_right();
		// pick the middle box
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		//bring the arm in front of mid block
		//pick the mid block
		rotation_using_blackline_right();
		blackline();
		forward();
		velocity(95,90);
		stop();
		blackline();
		//bridge crossed succesfully
		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_right();
		blackline();
		//drop the color box
		drop_the_block();
		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_right();
		blackline();
		// PICK THE WEIGHT BOX FROM WEIGHT B
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		rotation_using_blackline_right();
		blackline();
		forward();
		blackline();
		rotation_using_blackline_right();
		////drop the weight block in container
		drop_the_block();
		rotation_using_blackline_left();
		blackline();
		//PICK THE WT BLOCK from WEIGHT A
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);

		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_left();
		//drop the box
		drop_the_block();
		rotation_using_blackline_left();
		blackline();
		//pick the wt block
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);

		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_left();
		//drop the wt lock
		rotation_using_blackline_right();
		blackline();
		forward();
		velocity(95,90);
		stop();
		blackline();
		left_degrees(88);
		velocity(190,140);
		stop();
		//pick wt block from weight C
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);

		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_right();
		blackline();
		///3rd run for city area
		// CROSSING THE BRIDGE
		// NOW E AE IN CITY 1
		turn_left();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		velocity(190,180);
		forward_mm(113);
		stop();
		_delay_ms(1000);
		velocity(190,180);
		left_degrees(88);
		velocity(190,180);
		stop();
		_delay_ms(500);
		velocity(182,180);//187
		back_mm(83);//76
		stop();
		_delay_ms(500);
		// PICK THE WEIGTH BOX FROM WEIGHT A
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{


			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		_delay_ms(500);
		velocity(150,150);
		forward_mm(39);
		blackline();
		forward_mm(3);
		rotation_using_blackline_right();
		// DROP THE bOX IN CONTAINER OF CITY 1
		drop_the_block();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_left();
		blackline();
		// pick the weight box from weight b
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{


			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_left();
		blackline();
		//.. drop the wweight box in conntainer
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		forward_mm(8);
		rotation_using_blackline_right();
		// pick the bottom box
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		///// CROSS THE BRIDGE AGAIN
		forward();
		blackline();
		/// drop the bottom block
	}
	
	else if(flag3_color==top_HZ_waste_block_color)///////////////////////////////////////////////////
	{
		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_right();
		blackline();
		//// drop the color box
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		///////
		rotation_using_blackline_left();
		blackline();
		/// pick the weight box from weight a
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		rotation_using_blackline_left();
		blackline();
		forward();
		blackline();
		rotation_using_blackline_right();
		///// drop the weight box in container
		drop_the_block();
		rotation_using_blackline_left();
		blackline();
		///pick the weight box
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_left();
		drop_the_block();
		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_left();
		blackline();
		//BRIDGE CROSSED AND @ND RUN ON CITY AREA SIDE....AT NODE 'A' AND FACING TOWARDS HAZARDOUS WASTES
		// CROSSING THE BRIDGE
		// NOW E AE IN CITY 1
		turn_left();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		velocity(190,180);
		forward_mm(113);
		stop();
		_delay_ms(1000);
		velocity(190,180);
		left_degrees(88);
		velocity(190,180);
		stop();
		_delay_ms(500);
		velocity(182,180);//187
		back_mm(83);//76
		stop();
		_delay_ms(500);
		// PICK THE WEIGTH BOX FROM WEIGHT A
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{


			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		_delay_ms(500);
		velocity(150,150);
		forward_mm(39);
		blackline();
		forward_mm(3);
		rotation_using_blackline_right();
		// DROP THE bOX IN CONTAINER OF CITY 1
		drop_the_block();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_left();
		blackline();
		// pick the weight box from weight b
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{


			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_left();
		blackline();
		//.. drop the wweight box in conntainer
		drop_the_block();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		forward_mm(8);
		rotation_using_blackline_right();
		// pick the middle box
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		//bring the arm in front of mid block
		//pick the mid block
		rotation_using_blackline_right();
		blackline();
		forward();
		velocity(95,90);
		stop();
		blackline();
		//bridge crossed succesfully
		rotation_using_blackline_right();
		blackline();
		forward();
		blackline();
		rotation_using_blackline_left();
		blackline();
		//drop the color box
		drop_the_block();
		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_right();
		blackline();
		forward();
		blackline();
		forward();
		blackline();
		// PICK THE WEIGHT BOX FROM WEIGHT B
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		rotation_using_blackline_right();
		blackline();
		forward();
		blackline();
		rotation_using_blackline_right();
		////drop the weight block in container
		drop_the_block();
		rotation_using_blackline_left();
		blackline();
		//PICK THE WT BLOCK from WEIGHT A
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);

		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_left();
		//drop the box
		drop_the_block();
		rotation_using_blackline_left();
		blackline();
		//pick the wt block
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);

		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_left();
		//drop the wt lock
		rotation_using_blackline_right();
		blackline();
		forward();
		velocity(95,90);
		stop();
		blackline();
		left_degrees(88);
		velocity(190,140);
		stop();
		//pick wt block from weight C
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);

		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_right();
		blackline();
		///3rd run for city area
		// CROSSING THE BRIDGE
		// NOW E AE IN CITY 1
		turn_left();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		velocity(190,180);
		forward_mm(113);
		stop();
		_delay_ms(1000);
		velocity(190,180);
		left_degrees(88);
		velocity(190,180);
		stop();
		_delay_ms(500);
		velocity(182,180);//187
		back_mm(83);//76
		stop();
		_delay_ms(500);
		// PICK THE WEIGTH BOX FROM WEIGHT A
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{


			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		_delay_ms(500);
		velocity(150,150);
		forward_mm(39);
		blackline();
		forward_mm(3);
		rotation_using_blackline_right();
		// DROP THE bOX IN CONTAINER OF CITY 1
		drop_the_block();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_left();
		blackline();
		// pick the weight box from weight b
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{


			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_left();
		blackline();
		//.. drop the wweight box in conntainer
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		forward_mm(8);
		rotation_using_blackline_right();
		// pick the bottom box
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		///// CROSS THE BRIDGE AGAIN
		forward();
		blackline();
		/// drop the bottom block
	}
}
/////////////////////////////////////////CASE 3 BOTTOM AT C///////////////////
void bottom_at_C_not()
{
	
	if(top_HZ_waste_block_color==flag2_color) ///top AT B
	{   rotation_using_blackline_right();
		//DROP THE BOX AT B
		forward_mm(35);//TO be caliberated
		rotation_using_blackline_right();
		blackline();
		forward_mm(22);
		turn_right();
		velocity(190,180);
		stop();
		_delay_ms(1000);
		blackline();
		/// pick the weight from weight B
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{
			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		rotation_using_blackline_left();
		blackline();
		forward_mm(23);// to be caliberated
		velocity(190,180);
		stop();
		blackline();
		rotation_using_blackline_right();
		/// drop the weight box in conatiner
		drop_the_block();////////////////////////////////
		
		rotation_using_blackline_right();
		blackline();
		forward();
		velocity(95,90);
		_delay_ms(1100);
		blackline();
		//PICK WEIGHT BLOCK AT B WT =1 block
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{
			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		rotation_using_blackline_left();
		blackline();
		forward_mm(23);// to be caliberated
		velocity(190,180);
		stop();
		blackline();
		rotation_using_blackline_right();
		/// drop the weight box in conatiner
		drop_the_block();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_right();
		blackline();
		forward_mm(23);/// to be caliberated
		turn_left();
		velocity(190,180);
		stop();
		_delay_ms(1000);
		blackline();
		//BRIDGE CROSSED AND @ND RUN ON CITY AREA SIDE....AT NODE 'A' AND FACING TOWARDS HAZARDOUS WASTES
		// CROSSING THE BRIDGE
		// NOW E AE IN CITY 1
		turn_left();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		velocity(190,180);
		forward_mm(113);
		stop();
		_delay_ms(1000);
		velocity(190,180);
		left_degrees(88);
		velocity(190,180);
		stop();
		_delay_ms(500);
		velocity(182,180);//187
		back_mm(83);//76
		stop();
		_delay_ms(500);
		// PICK THE WEIGTH BOX FROM WEIGHT A
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{


			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		_delay_ms(500);
		velocity(150,150);
		forward_mm(39);
		blackline();
		forward_mm(3);
		rotation_using_blackline_right();
		// DROP THE bOX IN CONTAINER OF CITY 1
		drop_the_block();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_left();
		blackline();
		// pick the weight box from weight b
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{


			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_left();
		blackline();
		//.. drop the wweight box in conntainer
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		forward_mm(8);
		rotation_using_blackline_right();
		// pick the middle box
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		//bring the arm in front of mid block
		//pick the mid block
		rotation_using_blackline_right();
		blackline();
		forward();
		velocity(95,90);
		stop();
		blackline();
		//bridge crossed succesfully
		rotation_using_blackline_right();
		blackline();
		forward();
		velocity(95,90);
		stop();
		blackline();
		rotation_using_blackline_left();
		forward();   ////TO BE CALIBRATED
		velocity(95,90);
		stop();
		//drop the color box
		rotation_using_blackline_right();
		blackline();
		left_degrees(93);
		stop();
		//PICK THE WT BLOCK from WEIGHT A
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);

		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_left();
		//drop the box
		rotation_using_blackline_left();
		blackline();
		//pick the wt block
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);

		rotation_using_blackline_right();
		blackline();
		rotation_using_blackline_left();
		//drop the wt lock
		rotation_using_blackline_right();
		blackline();
		forward();
		velocity(95,90);
		stop();
		blackline();
		//pick wt block from weight C
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);

		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_right();
		blackline();
		///3rd run for city area
		// CROSSING THE BRIDGE
		// NOW E AE IN CITY 1
		turn_left();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		velocity(190,180);
		forward_mm(113);
		stop();
		_delay_ms(1000);
		velocity(190,180);
		left_degrees(88);
		velocity(190,180);
		stop();
		_delay_ms(500);
		velocity(182,180);//187
		back_mm(83);//76
		stop();
		_delay_ms(500);
		// PICK THE WEIGTH BOX FROM WEIGHT A
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{


			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		_delay_ms(500);
		velocity(150,150);
		forward_mm(39);
		blackline();
		forward_mm(3);
		rotation_using_blackline_right();
		// DROP THE bOX IN CONTAINER OF CITY 1
		drop_the_block();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_left();
		blackline();
		// pick the weight box from weight b
		servo_2(155);
		_delay_ms(1000);
		for(int i=0;i<=54;i+=2)
		{


			servo_1(i);
			_delay_ms(200);
		}
		//_delay_ms(2000);
		servo_3(131);
		_delay_ms(2000);
		forward_mm(24);
		rotation_using_blackline_left();
		blackline();
		stop();
		forward_mm(24);// to be caliberated
		rotation_using_blackline_left();
		blackline();
		//.. drop the wweight box in conntainer
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		forward_mm(8);
		rotation_using_blackline_right();
		// pick the bottom box
		servo_2(135);
		_delay_ms(1000);
		servo_3(0);
		_delay_ms(1000);
		for(int i=0;i<=40;i+=5)
		{
			servo_1(i);
			_delay_ms(1000);


		}
		_delay_ms(1000);
		servo_3(114);
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		turn_right();
		velocity(150,150);
		_delay_ms(50);
		stop();
		blackline();
		///// CROSS THE BRIDGE AGAIN
		rotation_using_blackline_left();
		blackline();
		rotation_using_blackline_right();
		blackline();
		/// drop the bottom block
	}

}
	/////////////////////////"NOT IN FAVOUR" ENDS///////////////////////////////////////////////////
	
		}}}}	
	
